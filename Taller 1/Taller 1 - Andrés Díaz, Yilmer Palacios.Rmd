---
title: "Taller 1"
author: "Andrés Díaz, Yilmer Palacios"
date: "2024-02-01"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(encoding = "utf-8")


```

## 1 Primer Punto

### 1.1) Definan una semilla para trabajar durante el script. Respondan: ¿Por qué es importante definir una semilla?

Respuesta: Según R-Coder.com, la definición de una semilla es que es el iniciador de un generador de números pseudoaleatorios, que son utilizados para la simulación de distribuciones de probabilidad que sean requeridas por el algoritmo. Al ser pseudoaleatorios, los resultados obtenidos a partir de estos números generados son replicables siempre y cuando se utilice el mismo generador y la misma semilla.

Es importante definir una semilla en un algoritmo que vaya a utilizar un generador de números con distribuciones de probabilidad ya que permite que otras personas puedan llegar al mismo resultado con el algoritmo y los datos utilizados. Si no se definiera, los resultados cambiarían cada vez que se ejecutara el código, dada la naturaleza de los datos que se está utilizando.

Para este ejercicio, se definirá la semilla usando la fecha en la que se comenzó a trabajar en este taller.

```{r semilla}

set.seed(31012024)

```

### 1.2) Primero, creen una lista con números secuenciales de 1 en 1 desde el 1 hasta el 50. Luego, creen tres (3) listas diferentes que contengan respectivamente: una variable numérica de clase int que se distribuya de forma uniforme entre el intervalo 5 a 50, una lista que repita el carácter “Años” y una lista con nombres propios aleatorios de personas, todas las cuatro (4) listas deben tener el mismo tamaño.

```{r listas}

set.seed(31012024) #La ejecutamos de nuevo para que tenga efecto sobre el runif
rm(list=ls())   # borramos environment
l_num = list(numeros = seq(1,50,1)) # Creamos la lista de 1 en 1 hasta 50
l_edad = list(edad= round(runif(50,5,50),0))# Creamos la lista de edades con una distribución uniforme entre 5 y 50
l_texto = list(variable=rep("años",50)) # Creamos una lista con la palabra "años" repetida 50 veces


# Para la lista de nombres vamos a crear dos vectores, uno con los nombres y otro con los apellidos de los integrantes del curso; luego usaremos la función sample para tomar de los vectores elementos aleatorios; finalmente, uniremos los nombres y apellidos aleatorios para formar la lista. Fuente: https://r-coder.com/funcion-sample-r/

rapellidos <- c("Aguirre", "Arteaga", "Borda", "Caballero", "Carbonell", "Carvajal", "Criollo", "Diaz", "Duquino", "Escobar", "Fernandez", "Fonseca", "Galindo", "Gonzalez", "Hernandez", "Huertas", "Karaman", "Lasso", "Naranjo", "Navarrete", "Navarro", "Neusa", "Osorno", "Palacios", "Patiño", "Perdomo", "Prada", "Rueda", "Villamizar", "Viveros", "Zuluaga", "Valencia", "Gomez", "Bejarano", "Silva", "Ortega", "Huerfano", "Cardenas", "Barreto", "Carreño", "Rocha", "Correa", "Jimenez", "Barragan", "Rincon", "Ramirez", "Charry", "Munoz", "Pedreros", "Lian", "Jaramillo", "DeZulategi", "Amaya", "Corredor", "Ortiz", "Rodriguez", "Martinez", "Olmos", "Echeverri", "Arias", "Moreno", "Rojas", "Aguilar", "Cuellar", "Guacheta", "Vargas", "Muaoz", "DelCastillo")

rnombres <- c("Dennis", "Diana", "Luis", "Alejandra", "Henry", "Pharad", "Andres", "Edinson", "Yuri", "Jose", "Laura", "German", "Valentina", "Daniel", "Samuel", "Manuela", "Manuel", "Angella", "Yilmer", "Raul", "Gabriel", "Angela", "Camilo", "Santiago", "Julian", "Juanita", "Juan", "Silvia", "Francisco", "Estefania", "Johana", "Carolina", "Olegario", "Valentina", "Nicolas", "Fernando", "Alejandro", "Romina", "Camila", "Salomon", "Sofia", "Felipe", "Enrique", "Katherine", "Sebastian", "Alexis", "Maria", "Alexander", "David", "Paula", "Felipe", "Juliana")

nom_apellido <- c(paste(sample(rnombres,50, replace=TRUE), sample(rapellidos,50, replace=TRUE)))

#Ahora si creamos la lista

l_nombres = list(nom_apellido)

```

### 1.3) Creen una lista en la que cada elemento j sea la concatenación de los elementos j de las tres listas creadas en el punto anterior. Ordenen y/o agreguen caracteres a cada elemento de la lista para que se consolide una oración con orden semántico que refleje la edad del individuo.

```{r lista concatenada}

l_oracion <- c()

#creamos un bucle que va desde 1 hasta el número de elementos (50), es cada paso del bucle se concatenarán con "paste" las listas y se guaradán en una posición de la lista "l_oracion"

for (i in 1:length(l_nombres[[1]])){
  
  l_oracion[[1]][i] <- paste(l_nombres[[1]][i],"tiene",l_edad[[1]][i],
                          l_texto[[1]][i])    
  
}

l_oracion

```

### 1.4) Usando un loop realicen un código que presente (print) la edad de cada uno de los individuos dentro de las listas, pero únicamente si el nombre del individuo empieza por una letra distinta de J y la edad sea distinta de un número par.

```{r loop selección de J}

## Creamos un ciclo for que va desde 1 hasta el número de elementos de la lista oración (50), luego pasamos a dos codicionales, el primero evalúa si el nombre inicia por J y el segundo si el residuo de dividir la edad en 2 es mayor que cero, si lo es, el número es impar, a los elementos que pasen ambas condiciones se les hará "print".

for (j in 1:length(l_oracion[[1]])){
  
  
  if(substring(l_oracion[[1]][j],1,1)=="J"){
    
    if(l_edad[[1]][j]%%2>0){
      
      print(l_oracion[[1]][j])
      
    }
    
  }

}


```
### 1.5) Programen una función que tome como entrada una lista con valores numéricos y que su output sea el promedio de los valores de la lista y la desviación estándar asociada a la misma muestra. Usando esta función respondan: ¿Cuál es la edad promedio de su lista? ¿Cuál es la desviación estándar?

```{r creación de función - promedio y desviación}

  funcion_param_stat <- function(lista_edad){
    
    media <- mean(lista_edad)
    des_est <- sd(lista_edad)
    print(paste("La edad promedio es",media))
    print(paste("La desviación estándar es",signif(des_est,4)))
    
  }

funcion_param_stat(l_edad[[1]])

```

### 1.6)	Programen una función que tome como entrada una lista con valores numéricos y estandarice los valores. Es decir, que los transforme a una normal estándar los datos. Apliquen las funciones que desarrollaron en el literal 1.5) dentro de la función que propongan en este literal

```{r función estandarización}

  funcion_norm_estan <- function(lista_edad){
    
    media <- mean(lista_edad)
    des_est <- sd(lista_edad)

    dist_estandar <- c()
    
    for (i in 1:length(lista_edad)){
    
    dist_estandar[i] <- (lista_edad[i]-media)/des_est
    
    }
    
    print(dist_estandar)
   
  }

dist_estandar <- funcion_norm_estan(l_edad[[1]])


```
### 1.7)	Por otra parte, generen una lista de listas llamada outcomes_nominales. Esta lista contendrá 3 vectores de 50 observaciones cada uno con los outcomes de interés: salario, índice de salud, experiencia laboral. Para esto, generen para cada vector valores numéricos de clase float basado en una distribución normal estándar con media 0 y varianza 1. 

```{r lista outcomes_nominales}

salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)

outcomes_nominales <- list(Salario = salario,IndiceSalud = ind_salud, ExpLaboral = exp_laboral)


```
### 1.8)	Creen una función que transforme una lista en una matriz. Para esto, la función debe tomar como input una lista y debe tener como output una matriz X que concatene los datos de esta lista y un vector de 1´s.

```{r lista a matriz}
  
  funcion_lista_matriz <- function(lista){
    
    vector_unos <- rep(1,length(lista[[1]]))
    matriz <- cbind(lista,vector_unos)
    
    print(matriz) 
    
  }

 funcion_lista_matriz(l_edad[[1]])

```
### 1.9)	A partir de la función anterior consoliden una matriz X con la edad de los individuos estandarizada y un vector de 1´s asociado a una constante.

```{r matriz edad estandarizada}

vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)


```

## Segundo punto

### 2.1)	Programen una función que tome como input una matriz X estocástica de rango completo y un vector yi, posteriormente, el output debe corresponder a una estimación puntual del estimador (β1) de Mínimos Cuadrados Ordinarios (MCO) para la muestra y a su error estándar asociado (σβ). 

```{r función MCO}

funcion_MCO <- function(matriz_in,vector_in){
  
    beta_1 <- solve(t(matriz_in) %*% matriz_in) %*% (t(matriz_in) %*% vector_in)
    print(beta_1)  
  
}

b <-  matrix(outcomes_nominales[[1]])
c <-  matrix(matriz_edad_estandar[,1])


a <-  funcion_MCO(matrix(outcomes_nominales[[1]]),matrix(matriz_edad_estandar[,1]))

                
```

### 2.2)	Utilizando un loop, apliquen esta función a los diferentes outcomes en las listas de outcomes_nominales, guarden los coeficientes estimados y las desviaciones estándar en una matriz donde la primera columna corresponde al nombre del outcome, la segunda columna al coeficiente estimado (β1) y la tercera al error estándar (σβ). En esta matriz, cada fila representará una estimación. 

```{r aplicación MCO}

matrizest = matrix("Vacio", nrow = length(outcomes_nominales), ncol = 3) #Creamos Matriz vacía de 

for(nout in 1:length(outcomes_nominales)){
  
  matrizest[nout,1] <- names(outcomes_nominales[nout]) #colocamos los nombres de las listas en la primea columna
  
  matrizest[nout,2] <- round(funcion_MCO(matrix(outcomes_nominales[[nout]]),matrix(matriz_edad_estandar[,1])),3) #usamos la función "funcio_MCO" para llenar la segunda columna con los estimadores de la regresión univariada edad normalizada vs cada outcome.
  
# Hallamos las matrices necesarias para el cálculo de la varianza y error estándar
  
  Yt <- t(matrix(matriz_edad_estandar[,1]))
  Y  <- matrix(matriz_edad_estandar[,1])
  B  <- matrizest[nout,2]
  Xt <- t(matrix(outcomes_nominales[[nout]]))
  n  <- length(matrix(outcomes_nominales[[1]]))
  k  <- 1  #Seleccionamos k = 1 porque las regresiones son independientes, entonces los grados de libertad serán 1
  var <- round(((Yt %*% Y)-((as.numeric(B) * Xt) %*% Y))/(n-k),3)
  ErrEstandar <- var/(n**0.5)
  matrizest[nout,3] <- ErrEstandar #Guardamos los errores estándar en la columna 3 de la matriz

}

matrizest

```

```{r Hacer regresiones con comando lm}
# Para probar que está bien los errores estándar y los betas
#y = c(matrix(matriz_edad_estandar[,1]))
#x1 = c(matrix(outcomes_nominales[[1]]))
#x2 = c(matrix(outcomes_nominales[[2]]))
#x3 = c(matrix(outcomes_nominales[[3]]))

#datos <- data.frame(y, x1, x2, x3)

#modelo1 = lm(y ~ -1 + x1, data = datos)
#modelo2 = lm(y ~ -1 + x2, data = datos)
#modelo3 = lm(y ~ -1 + x3, data = datos)

#summary(modelo1)
#summary(modelo2)
#summary(modelo3)

```
### 2.3)  Haciendo uso de un loop hagan un print para que, automáticamente y para cada outcome, se realice la interpretación econométrica de cada coeficiente de regresión que estimaron. Recuerden tener en cuenta las distribuciones de las variables para su interpretación. 

```{r aplicación MCO - Interpretación de resultados}


for(interpretación in 1:length(matrizest[1,])){
  
  print()
  
}

```

