---
title: "Taller 1"
author: "Andr√©s D√≠az, Yilmer Palacios"
date: "2024-02-01"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(encoding = "utf-8")


```

## 1 Primer Punto

### 1.1) Definan una semilla para trabajar durante el script. Respondan: ¬øPor qu√© es importante definir una semilla?

Respuesta: Seg√∫n R-Coder.com, la definici√≥n de una semilla es la inicializaci√≥n de un generador de n√∫meros pseudoaleatorios, que son utilizados para la simulaci√≥n de distribuciones de probabilidad que sean requeridas por el algoritmo. Al ser pseudoaleatorios, los resultados obtenidos a partir de estos n√∫meros generados son replicables siempre y cuando se utilice el mismo generador y la misma semilla.

Es importante definir una semilla en un algoritmo que vaya a utilizar un generador de n√∫meros con distribuciones de probabilidad ya que permite que otras personas puedan llegar al mismo resultado con el algoritmo y los datos utilizados. Si no se definiera, los resultados cambiar√≠an cada vez que se ejecutara el c√≥digo, dada la naturaleza de los datos que se est√° utilizando.

Para este ejercicio, se definir√° la semilla usando la fecha en la que se comenz√≥ a trabajar en este taller.

```{r semilla}

set.seed(31012024)

```

### 1.2) Primero, creen una lista con n√∫meros secuenciales de 1 en 1 desde el 1 hasta el 50. Luego, creen tres (3) listas diferentes que contengan respectivamente: una variable num√©rica de clase int que se distribuya de forma uniforme entre el intervalo 5 a 50, una lista que repita el car√°cter ‚ÄúA√±os‚Äù y una lista con nombres propios aleatorios de personas, todas las cuatro (4) listas deben tener el mismo tama√±o.

```{r listas}

rm(list=ls())   # borramos environment
l_num = list(numeros = seq(1,50,1)) # Creamos la lista de 1 en 1 hasta 50
l_edad = list(edad= signif(round(runif(50,5,50),1),1))# Creamos la lista de edades con una distribuci√≥n uniforme entre 5 y 50
l_texto = list(variable=rep("a√±os",50)) # Creamos una lista con la palabra "a√±os" repetida 50 veces


# Para la lista de nombres vamos a crear dos vectores, uno con los nombres y otro con los apellidos de los integrantes del curso; luego usaremos la funci√≥n sample para tomar de los vectores elementos aleatorios; finalmente, uniremos los nombres y apellidos aleatorios para formar la lista. Fuente: https://r-coder.com/funcion-sample-r/

rapellidos <- c("Aguirre", "Arteaga", "Borda", "Caballero", "Carbonell", "Carvajal", "Criollo", "Diaz", "Duquino", "Escobar", "Fernandez", "Fonseca", "Galindo", "Gonzalez", "Hernandez", "Huertas", "Karaman", "Lasso", "Naranjo", "Navarrete", "Navarro", "Neusa", "Osorno", "Palacios", "Pati√±o", "Perdomo", "Prada", "Rueda", "Villamizar", "Viveros", "Zuluaga", "Valencia", "Gomez", "Bejarano", "Silva", "Ortega", "Huerfano", "Cardenas", "Barreto", "Carre√±o", "Rocha", "Correa", "Jimenez", "Barragan", "Rincon", "Ramirez", "Charry", "Munoz", "Pedreros", "Lian", "Jaramillo", "DeZulategi", "Amaya", "Corredor", "Ortiz", "Rodriguez", "Martinez", "Olmos", "Echeverri", "Arias", "Moreno", "Rojas", "Aguilar", "Cuellar", "Guacheta", "Vargas", "Muaoz", "DelCastillo")

rnombres <- c("Dennis", "Diana", "Luis", "Alejandra", "Henry", "Pharad", "Andres", "Edinson", "Yuri", "Jose", "Laura", "German", "Valentina", "Daniel", "Samuel", "Manuela", "Manuel", "Angella", "Yilmer", "Raul", "Gabriel", "Angela", "Camilo", "Santiago", "Julian", "Juanita", "Juan", "Silvia", "Francisco", "Estefania", "Johana", "Carolina", "Olegario", "Valentina", "Nicolas", "Fernando", "Alejandro", "Romina", "Camila", "Salomon", "Sofia", "Felipe", "Enrique", "Katherine", "Sebastian", "Alexis", "Maria", "Alexander", "David", "Paula", "Felipe", "Juliana")

nom_apellido <- c(paste(sample(rnombres,50, replace=TRUE), sample(rapellidos,50, replace=TRUE)))

#Ahora si creamos la lista

l_nombres = list(nom_apellido)

```

### 1.3) Creen una lista en la que cada elemento j sea la concatenaci√≥n de los elementos j de las tres listas creadas en el punto anterior. Ordenen y/o agreguen caracteres a cada elemento de la lista para que se consolide una oraci√≥n con orden sem√°ntico que refleje la edad del individuo.

```{r lista concatenada}

l_oracion <- c()

for (i in 1:length(l_nombres[[1]])){
  
  l_oracion[[1]][i] <- paste(l_nombres[[1]][i],"tiene",l_edad[[1]][i],
                          l_texto[[1]][i])    
  
}

l_oracion

```

### 1.4) Usando un loop realicen un c√≥digo que presente (print) la edad de cada uno de los individuos dentro de las listas, pero √∫nicamente si el nombre del individuo empieza por una letra distinta de J y la edad sea distinta de un n√∫mero par.

```{r loop selecci√≥n de J}


for (j in 1:length(l_oracion[[1]])){
  
  
  if(substring(l_oracion[[1]][j],1,1)=="J"){
    
    if(l_edad[[1]][j]%%2>0){
      
      print(l_oracion[[1]][j])
      
    }
    
  }
  

}


```

### 1.5) Programen una funci√≥n que tome como entrada una lista con valores num√©ricos y que su output sea el promedio de los valores de la lista y la desviaci√≥n est√°ndar asociada a la misma muestra. Usando esta funci√≥n respondan: ¬øCu√°l es la edad promedio de su lista? ¬øCu√°l es la desviaci√≥n est√°ndar?

```{r creaci√≥n de funci√≥n - promedio y desviaci√≥n}

  funcion_param_stat <- function(lista_edad){
    
    media <- mean(lista_edad)
    des_est <- sd(lista_edad)
    print(paste("La edad promedio es",media))
    print(paste("La desviaci√≥n est√°ndar es",signif(des_est,4)))
    
  }

funcion_param_stat(l_edad[[1]])

```

### 1.6)	Programen una funci√≥n que tome como entrada una lista con valores num√©ricos y estandarice los valores. Es decir, que los transforme a una normal est√°ndar los datos. Apliquen las funciones que desarrollaron en el literal 1.5) dentro de la funci√≥n que propongan en este literal

```{r funci√≥n estandarizaci√≥n}

  funcion_norm_estan <- function(lista_edad){
    
    media <- mean(lista_edad)
    des_est <- sd(lista_edad)

    
    dist_estandar <- c()
    
    for (i in 1:length(lista_edad)){
    
    dist_estandar[i] <- (lista_edad[i]-media)/des_est
    
    }
    
    print(dist_estandar)
   
    
  }

dist_estandar <- funcion_norm_estan(l_edad[[1]])


```
### 1.7)	Por otra parte, generen una lista de listas llamada outcomes_nominales. Esta lista contendr√° 3 vectores de 50 observaciones cada uno con los outcomes de inter√©s: salario, √≠ndice de salud, experiencia laboral. Para esto, generen para cada vector valores num√©ricos de clase float basado en una distribuci√≥n normal est√°ndar con media 0 y varianza 1. 

```{r lista outcomes_nominales}

salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)

outcomes_nominales <- list(salario,ind_salud,exp_laboral)


```
### 1.8)	Creen una funci√≥n que transforme una lista en una matriz. Para esto, la funci√≥n debe tomar como input una lista y debe tener como output una matriz X que concatene los datos de esta lista y un vector de 1¬¥s.

```{r lista a matriz}
  
  funcion_lista_matriz <- function(lista){
    
    vector_unos <- rep(1,length(lista[[1]]))
    matriz <- cbind(lista,vector_unos)
    
    print(matriz)
    
  }

  funcion_lista_matriz(l_edad[[1]])

```
### 1.9)	A partir de la funci√≥n anterior consoliden una matriz X con la edad de los individuos estandarizada y un vector de 1¬¥s asociado a una constante.

```{r matriz edad estandarizada}

vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)

```

## Segundo punto

### Programen una funciÛn que tome como input una matriz X estoc·stica de rango completo y un vector??? y???_i, posteriormente, el output debe corresponder a una estimaciÛn puntual del estimador (ﬂ_1) de MÌnimos Cuadrados Ordinarios (MCO) para la muestra y a su error est·ndar asociado (s_ﬂ).

```{r funciÛn MCO}

funcion_MCO <- function(matriz_in,vector_in){
  
    beta_1 <- inv(t(matriz_in) %*% matriz_in) %*% (t(matriz_in) %*% vector_in)
    print(beta_1)  
  
}

```

### 	Utilizando un loop, apliquen esta funciÛn a los diferentes outcomes en las listas de outcomes_nominales, guarden los coeficientes estimados y las desviaciones est·ndar en una matriz donde la primera columna corresponde al nombre del outcome, la segunda columna al coeficiente estimado (ﬂ_1) y la tercera al error est·ndar (s_ﬂ). En esta matriz, cada fila representar· una estimaciÛn. 

```{r aplicaciÛn MCO}

