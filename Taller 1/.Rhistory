knitr::opts_chunk$set(echo = TRUE)
set.seed(31012024)
rm(list=ls())   # borramos environment
l_num = list(numeros = seq(1,50,1)) # Creamos la lista de 1 en 1 hasta 50
l_edad = list(edad= runif(50,5,50)) # Creamos la lista de edades con una distribución uniforme entre 5 y 50
l_texto = list(variable=rep("años",50)) # Creamos una lista con la palabra "años" repetida 50 veces
# Para la lista de nombres vamos a crear 2 vectores, uno con nombres y otro con apellidos tomados de los nombres y apellidos de los integrantes del curso; luego usaremos la función sample para tomar de los vectores elementos aleatorios, finalmente uniremos los nombres y apellidos aleatorios para formar la lista. Fuente: https://r-coder.com/funcion-sample-r/
rapellidos <- c("Aguirre", "Arteaga", "Borda", "Caballero", "Carbonell", "Carvajal", "Criollo", "Diaz", "Duquino", "Escobar", "Fernandez", "Fonseca", "Galindo", "Gonzalez", "Hernandez", "Huertas", "Karaman", "Lasso", "Naranjo", "Navarrete", "Navarro", "Neusa", "Osorno", "Palacios", "Patiño", "Perdomo", "Prada", "Rueda", "Villamizar", "Viveros", "Zuluaga", "Valencia", "Gomez", "Bejarano", "Silva", "Ortega", "Huerfano", "Cardenas", "Barreto", "Carreño", "Rocha", "Correa", "Jimenez", "Barragan", "Rincon", "Ramirez", "Charry", "Munoz", "Pedreros", "Lian", "Jaramillo", "DeZulategi", "Amaya", "Corredor", "Ortiz", "Rodriguez", "Martinez", "Olmos", "Echeverri", "Arias", "Moreno", "Rojas", "Aguilar", "Cuellar", "Guacheta", "Vargas", "Muaoz", "DelCastillo")
rnombres <- c("Dennis", "Diana", "Luis", "Alejandra", "Henry", "Pharad", "Andres", "Edinson", "Yuri", "Jose", "Laura", "German ", "Valentina ", "Daniel", "Samuel", "Manuela", "Manuel", "Angella", "Yilmer", "Raul", "Gabriel", "Angela", "Camilo", "Santiago ", "Julian", "Juanita", "Juan", "Silvia", "Francisco", "Estefania", "Johana", "Carolina ", "Olegario", "Valentina", "Nicolas", "Fernando", "Alejandro", "Romina", "Camila", "Salomon", "Sofia", "Felipe ", "Enrique", "Katherine", "Sebastian", "Alexis ", "Maria", "Alexander", "David", "Paula", "Felipe", "Juliana")
nom_apellido <- c(paste(sample(rnombres,50, replace=TRUE), sample(rapellidos,50, replace=TRUE)))
#Ahora si creamos la lista
l_nombres = list(nom_apellido)
knitr::opts_chunk$set(echo = TRUE)
options(encoding = "utf-8")
matrizest = matrix("Vacio", nrow = length(outcomes_nominales), ncol = 3) #Creamos Matriz vacía de
funcion_MCO_beta1 <- function(matriz_in,vector_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# vector_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   vector_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Beta_1
beta_1[1]
}
funcion_MCO_ee_beta1 <- function(matriz_in,vector_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# vector_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   vector_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al           cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Error estándar de Beta_1
eeBeta_1
}
#Estimación de variables
X <- matriz_edad_estandar
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
knitr::opts_chunk$set(echo = TRUE)
options(encoding = "utf-8")
set.seed(31012024)
set.seed(31012024) #La ejecutamos de nuevo para que tenga efecto sobre el runif
rm(list=ls())   # borramos environment
l_num = list(numeros = seq(1,50,1)) # Creamos la lista de 1 en 1 hasta 50
l_edad = list(edad= round(runif(50,5,50),0))# Creamos la lista de edades con una distribución uniforme entre 5 y 50
l_texto = list(variable=rep("años",50)) # Creamos una lista con la palabra "años" repetida 50 veces
# Para la lista de nombres vamos a crear dos vectores, uno con los nombres y otro con los apellidos de los integrantes del curso; luego usaremos la función sample para tomar de los vectores elementos aleatorios; finalmente, uniremos los nombres y apellidos aleatorios para formar la lista. Fuente: https://r-coder.com/funcion-sample-r/
rapellidos <- c("Aguirre", "Arteaga", "Borda", "Caballero", "Carbonell", "Carvajal", "Criollo", "Diaz", "Duquino", "Escobar", "Fernandez", "Fonseca", "Galindo", "Gonzalez", "Hernandez", "Huertas", "Karaman", "Lasso", "Naranjo", "Navarrete", "Navarro", "Neusa", "Osorno", "Palacios", "Patiño", "Perdomo", "Prada", "Rueda", "Villamizar", "Viveros", "Zuluaga", "Valencia", "Gomez", "Bejarano", "Silva", "Ortega", "Huerfano", "Cardenas", "Barreto", "Carreño", "Rocha", "Correa", "Jimenez", "Barragan", "Rincon", "Ramirez", "Charry", "Munoz", "Pedreros", "Lian", "Jaramillo", "DeZulategi", "Amaya", "Corredor", "Ortiz", "Rodriguez", "Martinez", "Olmos", "Echeverri", "Arias", "Moreno", "Rojas", "Aguilar", "Cuellar", "Guacheta", "Vargas", "Muaoz", "DelCastillo")
rnombres <- c("Dennis", "Diana", "Luis", "Alejandra", "Henry", "Pharad", "Andres", "Edinson", "Yuri", "Jose", "Laura", "German", "Valentina", "Daniel", "Samuel", "Manuela", "Manuel", "Angella", "Yilmer", "Raul", "Gabriel", "Angela", "Camilo", "Santiago", "Julian", "Juanita", "Juan", "Silvia", "Francisco", "Estefania", "Johana", "Carolina", "Olegario", "Valentina", "Nicolas", "Fernando", "Alejandro", "Romina", "Camila", "Salomon", "Sofia", "Felipe", "Enrique", "Katherine", "Sebastian", "Alexis", "Maria", "Alexander", "David", "Paula", "Felipe", "Juliana")
nom_apellido <- c(paste(sample(rnombres,50, replace=TRUE), sample(rapellidos,50, replace=TRUE)))
#Ahora si creamos la lista
l_nombres = list(nom_apellido)
l_oracion <- c()
#creamos un bucle que va desde 1 hasta el número de elementos (50), es cada paso del bucle se concatenarán con "paste" las listas y se guaradán en una posición de la lista "l_oracion"
for (i in 1:length(l_nombres[[1]])){
l_oracion[[1]][i] <- paste(l_nombres[[1]][i],"tiene",l_edad[[1]][i],
l_texto[[1]][i])
}
l_oracion
## Creamos un ciclo for que va desde 1 hasta el número de elementos de la lista oración (50), luego pasamos a dos codicionales, el primero evalúa si el nombre inicia por J y el segundo si el residuo de dividir la edad en 2 es mayor que cero, si lo es, el número es impar, a los elementos que pasen ambas condiciones se les hará "print".
for (j in 1:length(l_oracion[[1]])){
if(substring(l_oracion[[1]][j],1,1)!="J"){
if(l_edad[[1]][j]%%2>0){
print(l_oracion[[1]][j])
}
}
}
funcion_param_stat <- function(lista_edad){
media <- mean(lista_edad)
des_est <- sd(lista_edad)
print(paste("La edad promedio es",media))
print(paste("La desviación estándar es",signif(des_est,4)))
}
funcion_param_stat(l_edad[[1]])
funcion_norm_estan <- function(listaval){
media <- mean(listaval)
des_est <- sd(listaval)
dist_estandar <- c()
for (i in 1:length(listaval)){
dist_estandar[i] <- (listaval[i]-media)/des_est
}
print(dist_estandar)
}
dist_estandar <- funcion_norm_estan(l_edad[[1]])
salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)
outcomes_nominales <- list(Salario = salario,IndiceSalud = ind_salud, ExpLaboral = exp_laboral)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
matriz_edad_estandar
funcion_MCO_beta1 <- function(matriz_in,vector_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# vector_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   vector_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Beta_1
beta_1[1]
}
funcion_MCO_ee_beta1 <- function(matriz_in,vector_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# vector_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   vector_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al           cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Error estándar de Beta_1
eeBeta_1
}
#Estimación de variables
X <- matriz_edad_estandar
y_in <-  matrix(outcomes_nominales[[1]])
funcion_MCO_beta1(X,y_in)
funcion_MCO_ee_beta1(X,y_in)
matrizest = matrix("Vacio", nrow = length(outcomes_nominales), ncol = 3) #Creamos Matriz vacía de
for(nout in 1:length(outcomes_nominales)){
matrizest[nout,1] <- names(outcomes_nominales[nout]) #colocamos los nombres de las listas en la primera columna
matrizest[nout,2] <- round(funcion_MCO_beta1(matrix(outcomes_nominales[[nout]]),matrix(matriz_edad_estandar[,1])),3) #usamos la función "funcio_MCO" para llenar la segunda columna con los estimadores de la regresión univariada edad normalizada vs cada outcome.
# Hallamos las matrices necesarias para el cálculo de la varianza y error estándar
Yt <- t(matrix(matriz_edad_estandar[,1]))
Y  <- matrix(matriz_edad_estandar[,1])
B  <- matrizest[nout,2]
Xt <- t(matrix(outcomes_nominales[[nout]]))
n  <- length(matrix(outcomes_nominales[[1]]))
k  <- 1  #Seleccionamos k = 1 porque las regresiones son independientes, entonces los grados de libertad serán 1
var <- round(((Yt %*% Y)-((as.numeric(B) * Xt) %*% Y))/(n-k),3)
ErrEstandar <- var/(n**0.5)
matrizest[nout,3] <- ErrEstandar #Guardamos los errores estándar en la columna 3 de la matriz
}
matrizest
#####Elaboración Andrés
#Se hace un loop en el que se concatenan los nombres de las
#variables, los estimadores de la regresión por MCO y sus
#errores estándar
#Se crea una matriz vacía con la dimensión deseada:
# La cantidad de filas igual a la cantidad de resultados
# La cantidad de columnas igual a 3: nombre, beta y error estándar
matriz_Estimadores <- matrix(NA,nrow = length(outcomes_nominales),
ncol = 3)
for (i in 1:length(outcomes_nominales)){
#Input
# Funciones de estimación de betas y de errores estándar
# Vectores de los outcomes
beta <- funcion_MCO_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
error_est <- funcion_MCO_ee_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
#Output
matriz_Estimadores [i,1] <-  names(outcomes_nominales[i])
matriz_Estimadores [i,2] <-  round(beta,3)
matriz_Estimadores [i,3] <-  round(error_est,3)
}
print(matriz_Estimadores)
