#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
matriz
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
matriz_edad_estandar
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
invisible(matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar))
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
matriz_edad_estandar
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
matriz_edad_estandar
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
invisible(matriz)
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
}
matriz = funcion_lista_matriz(l_edad[[1]])
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
invisible(vect_edad_estandar <- funcion_norm_estan(l_edad[[1]]))
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
funcion_norm_estan <- function(listaval){
media <- mean(listaval)
des_est <- sd(listaval)
dist_estandar <- c()
for (i in 1:length(listaval)){
dist_estandar[i] <- (listaval[i]-media)/des_est
}
}
dist_estandar <- funcion_norm_estan(l_edad[[1]])
set.seed(31012024)
salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)
outcomes_nominales <- list(Salario = salario,IndiceSalud = ind_salud, ExpLaboral = exp_laboral)
print(outcomes_nominales)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
## Creamos un ciclo for que va desde 1 hasta el número de elementos de la lista oración (50), luego pasamos a dos codicionales, el primero evalúa si el nombre inicia por J y el segundo si el residuo de dividir la edad en 2 es mayor que cero, si lo es, el número es impar, a los elementos que pasen ambas condiciones se les hará "print".
for (j in 1:length(l_oracion[[1]])){
if(substring(l_oracion[[1]][j],1,1)!="J"){
if(l_edad[[1]][j]%%2>0){
print(l_oracion[[1]][j])
}
}
}
funcion_param_stat <- function(lista_edad){
media <- mean(lista_edad)
des_est <- sd(lista_edad)
print(paste("La edad promedio es",media))
print(paste("La desviación estándar es",signif(des_est,4)))
}
funcion_param_stat(l_edad[[1]])
funcion_norm_estan <- function(listaval){
media <- mean(listaval)
des_est <- sd(listaval)
dist_estandar <- c()
for (i in 1:length(listaval)){
dist_estandar[i] <- (listaval[i]-media)/des_est
}
print(dist_estandar)
}
dist_estandar <- funcion_norm_estan(l_edad[[1]])
set.seed(31012024)
salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)
outcomes_nominales <- list(Salario = salario,IndiceSalud = ind_salud, ExpLaboral = exp_laboral)
print(outcomes_nominales)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
#Creamos dos funciones exactas salvo que la primera devuelve el estimado beta B y la segunda su error estándar.
funcion_MCO_beta1 <- function(matriz_in,y_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# y_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   y_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Beta_1
beta_1[1]
}
funcion_MCO_ee_beta1 <- function(matriz_in,y_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# y_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   y_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al           cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Error estándar de Beta_1
eeBeta_1
}
#Estimación de variables (Prueba)
#X <- matriz_edad_estandar
#y_in <-  matrix(outcomes_nominales[[1]])
#funcion_MCO_beta1(X,y_in)
#funcion_MCO_ee_beta1(X,y_in)
#Se hace un loop en el que se concatenan los nombres de las
#variables, los estimadores de la regresión por MCO y sus
#errores estándar
#Se crea una matriz vacía con la dimensión deseada:
# La cantidad de filas igual a la cantidad de resultados
# La cantidad de columnas igual a 3: nombre, beta y error estándar
matriz_Estimadores <- matrix(NA,nrow = length(outcomes_nominales),
ncol = 3)
for (i in 1:length(outcomes_nominales)){
#Input
# Funciones de estimación de betas y de errores estándar
# Vectores de los outcomes
beta <- funcion_MCO_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
error_est <- funcion_MCO_ee_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
#Output
matriz_Estimadores [i,1] <-  names(outcomes_nominales[i])
matriz_Estimadores [i,2] <-  round(beta,3)
matriz_Estimadores [i,3] <-  round(error_est,3)
}
print(matriz_Estimadores)
knitr::opts_chunk$set(echo = TRUE)
options(encoding = "utf-8")
set.seed(31012024)
set.seed(31012024) #La ejecutamos de nuevo para que tenga efecto sobre el runif
rm(list=ls())   # borramos environment
l_num = list(numeros = seq(1,50,1)) # Creamos la lista de 1 en 1 hasta 50
l_edad = list(edad= round(runif(50,5,50),0))# Creamos la lista de edades con una distribución uniforme entre 5 y 50
l_texto = list(variable=rep("años",50)) # Creamos una lista con la palabra "años" repetida 50 veces
# Para la lista de nombres vamos a crear dos vectores, uno con los nombres y otro con los apellidos de los integrantes del curso; luego usaremos la función sample para tomar de los vectores elementos aleatorios; finalmente, uniremos los nombres y apellidos aleatorios para formar la lista. Fuente: https://r-coder.com/funcion-sample-r/
rapellidos <- c("Aguirre", "Arteaga", "Borda", "Caballero", "Carbonell", "Carvajal", "Criollo", "Diaz", "Duquino", "Escobar", "Fernandez", "Fonseca", "Galindo", "Gonzalez", "Hernandez", "Huertas", "Karaman", "Lasso", "Naranjo", "Navarrete", "Navarro", "Neusa", "Osorno", "Palacios", "Patiño", "Perdomo", "Prada", "Rueda", "Villamizar", "Viveros", "Zuluaga", "Valencia", "Gomez", "Bejarano", "Silva", "Ortega", "Huerfano", "Cardenas", "Barreto", "Carreño", "Rocha", "Correa", "Jimenez", "Barragan", "Rincon", "Ramirez", "Charry", "Munoz", "Pedreros", "Lian", "Jaramillo", "DeZulategi", "Amaya", "Corredor", "Ortiz", "Rodriguez", "Martinez", "Olmos", "Echeverri", "Arias", "Moreno", "Rojas", "Aguilar", "Cuellar", "Guacheta", "Vargas", "Muaoz", "DelCastillo")
rnombres <- c("Dennis", "Diana", "Luis", "Alejandra", "Henry", "Pharad", "Andres", "Edinson", "Yuri", "Jose", "Laura", "German", "Valentina", "Daniel", "Samuel", "Manuela", "Manuel", "Angella", "Yilmer", "Raul", "Gabriel", "Angela", "Camilo", "Santiago", "Julian", "Juanita", "Juan", "Silvia", "Francisco", "Estefania", "Johana", "Carolina", "Olegario", "Valentina", "Nicolas", "Fernando", "Alejandro", "Romina", "Camila", "Salomon", "Sofia", "Felipe", "Enrique", "Katherine", "Sebastian", "Alexis", "Maria", "Alexander", "David", "Paula", "Felipe", "Juliana")
nom_apellido <- c(paste(sample(rnombres,50, replace=TRUE), sample(rapellidos,50, replace=TRUE)))
#Ahora si creamos la lista
l_nombres = list(nom_apellido)
l_oracion <- c()
#creamos un bucle que va desde 1 hasta el número de elementos (50), es cada paso del bucle se concatenarán con "paste" las listas y se guaradán en una posición de la lista "l_oracion"
for (i in 1:length(l_nombres[[1]])){
l_oracion[[1]][i] <- paste(l_nombres[[1]][i],"tiene",l_edad[[1]][i],
l_texto[[1]][i])
}
l_oracion
## Creamos un ciclo for que va desde 1 hasta el número de elementos de la lista oración (50), luego pasamos a dos codicionales, el primero evalúa si el nombre inicia por J y el segundo si el residuo de dividir la edad en 2 es mayor que cero, si lo es, el número es impar, a los elementos que pasen ambas condiciones se les hará "print".
for (j in 1:length(l_oracion[[1]])){
if(substring(l_oracion[[1]][j],1,1)!="J"){
if(l_edad[[1]][j]%%2>0){
print(l_oracion[[1]][j])
}
}
}
funcion_param_stat <- function(lista_edad){
media <- mean(lista_edad)
des_est <- sd(lista_edad)
print(paste("La edad promedio es",media))
print(paste("La desviación estándar es",signif(des_est,4)))
}
funcion_param_stat(l_edad[[1]])
funcion_norm_estan <- function(listaval){
media <- mean(listaval)
des_est <- sd(listaval)
dist_estandar <- c()
for (i in 1:length(listaval)){
dist_estandar[i] <- (listaval[i]-media)/des_est
}
print(dist_estandar)
}
dist_estandar <- funcion_norm_estan(l_edad[[1]])
set.seed(31012024)
salario <- rnorm(50,0,1)
ind_salud <- rnorm(50,0,1)
exp_laboral <- rnorm(50,0,1)
outcomes_nominales <- list(Salario = salario,IndiceSalud = ind_salud, ExpLaboral = exp_laboral)
print(outcomes_nominales)
funcion_lista_matriz <- function(lista){
#Input
#Vector de unos con la longitud de la edad
#Vector de la edad con la edad
vector_unos <- matrix(rep(1,length(lista[[1]])),nrow=length(l_edad[[1]]))
matriz <- cbind(lista,vector_unos)
colnames(matriz)[1] <- "Edad"
colnames(matriz)[2] <- "Constante"
matriz
}
matriz = funcion_lista_matriz(l_edad[[1]])
print(matriz)
class(matriz)
vect_edad_estandar <- funcion_norm_estan(l_edad[[1]])
matriz_edad_estandar <- funcion_lista_matriz(vect_edad_estandar)
colnames(matriz_edad_estandar)[1] <- "Edad estándar"
print(matriz_edad_estandar)
#Creamos dos funciones exactas salvo que la primera devuelve el estimado beta B y la segunda su error estándar.
funcion_MCO_beta1 <- function(matriz_in,y_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# y_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   y_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Beta_1
beta_1[1]
}
funcion_MCO_ee_beta1 <- function(matriz_in,y_in){
#Input
# Matriz_in: Matriz estocástica de rango completo
# y_in: Vector y_i
#Fórmula 1
# Beta_1 = (t(X)*X)^-1*(t(X)*y_i)
beta_1 <- solve(t(matriz_in) %*% matriz_in) %*%
(t(matriz_in) %*%   y_in)
#Fórmula 2
# ee(Beta_1) = (Var(error)/STC)^0.5
# Var(error) = SRC/(n-k-1) #Varianza del error
#SRC = suma((y_pred - y_in)^2) #Sumatoria de los residuales al           cuadrado
# k = 1 porque se van a hacer regresiones lineales simples
#y_pred = X*beta_1 #Resultado predicho
# STC = suma((y_in - mean(y_in))^2) #Suma Total de Cuadrados
y_pred <- matriz_in  %*% beta_1
SRC <- sum((y_pred - y_in)^2)
Var_error <- SRC/(length(y_in)-1-1)
STC <- sum((y_in - mean(y_in))^2)
eeBeta_1 <- (Var_error/STC)^0.5
#Output
# Error estándar de Beta_1
eeBeta_1
}
#Estimación de variables (Prueba)
#X <- matriz_edad_estandar
#y_in <-  matrix(outcomes_nominales[[1]])
#funcion_MCO_beta1(X,y_in)
#funcion_MCO_ee_beta1(X,y_in)
#Se hace un loop en el que se concatenan los nombres de las
#variables, los estimadores de la regresión por MCO y sus
#errores estándar
#Se crea una matriz vacía con la dimensión deseada:
# La cantidad de filas igual a la cantidad de resultados
# La cantidad de columnas igual a 3: nombre, beta y error estándar
matriz_Estimadores <- matrix(NA,nrow = length(outcomes_nominales),
ncol = 3)
for (i in 1:length(outcomes_nominales)){
#Input
# Funciones de estimación de betas y de errores estándar
# Vectores de los outcomes
beta <- funcion_MCO_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
error_est <- funcion_MCO_ee_beta1(matriz_edad_estandar,
matrix(outcomes_nominales[[i]]))
#Output
matriz_Estimadores [i,1] <-  names(outcomes_nominales[i])
matriz_Estimadores [i,2] <-  round(beta,3)
matriz_Estimadores [i,3] <-  round(error_est,3)
}
print(matriz_Estimadores)
# Para probar que está bien los errores estándar y los betas
x = matriz_edad_estandar
y1 = c(matrix(outcomes_nominales[[1]]))
y2 = c(matrix(outcomes_nominales[[2]]))
y3 = c(matrix(outcomes_nominales[[3]]))
datos <- data.frame(x, y1, y2, y3)
modelo1 = lm(y1 ~ -1 + x, data = datos)
modelo2 = lm(y2 ~ -1 + x, data = datos)
modelo3 = lm(y3 ~ -1 + x, data = datos)
Mod1 = summary(modelo1)
Mod2 = summary(modelo2)
Mod3 = summary(modelo3)
Mod1[["coefficients"]]
Mod2[["coefficients"]]
Mod3[["coefficients"]]
??summary
for (i in 1:length(outcomes_nominales)){
print(paste("Por cada incremento de una desviación estándar de la edad, la variable",matriz_Estimadores[i,1],"cambia en",matriz_Estimadores[i,2],"desviaciones estándar"))
}
#for(interpretación in 1:length(matrizest[1,])){
# print()
#}
#Se crea una función para determinar el MSE
funcion_MSE <- function(y_in,X_in,beta0,beta1){
#Input
#y_in: Un vector del resultado
#X_in: Una matriz de los valores independientes
#beta0: Valor de la constante de la regresión lineal simple
#beta1: Estimador de la regresión para la variable independiente
#Output
#MSE: Error al cuadrado promedio
MSE <- sum((y_in - beta0 - beta1*X_in)^2)/length(y_in)
}
funcion_MSE(matrix(outcomes_nominales[[1]]),
matrix(matriz_edad_estandar[,1]),1,1)
funcion_Min_MSE <- function(y_in,X_in,beta) {
#Valores iniciales
i <- -1 #Diferencia entre MSE
beta_1 <- -5 #Valor inicial de beta
paso_iteracion <- 0.001 #El incremento de beta_1 por iteración
MSE_t_1 <- funcion_MSE(y_in,X_in,0,(beta_1-paso_iteracion)) #Valor inicial de MSE, como es la inicial decidimos usar beta con un paso menos
while(i<0){
#Se utiliza la función MSE del punto anterior
invisible(MSE <- funcion_MSE(y_in,X_in,0,beta_1))
#Se calcula la diferencia entre el MSE actual y el de la iteración
#anterior
i <- MSE - MSE_t_1
#Se actualiza el valor del MSE para pasar a la siguiente iteración
MSE_t_1 <- MSE
#Se incrementa el valor de beta en un valor constante dado por
#el valor del paso de la iteración
beta_1 <- beta_1 + paso_iteracion
}
beta_1
}
matriz_Est_numerico <- matrix(NA,nrow = length(outcomes_nominales),
ncol = 2)
for (i in 1:length(outcomes_nominales)){
#input
#vector de y_in
#matriz de X
#beta_0 = 0
#Se hace un loop para que abarque todos los outcomes
matriz_Est_numerico [i,1] <- names(outcomes_nominales[i])
matriz_Est_numerico [i,2] <- round(funcion_Min_MSE(
matrix(outcomes_nominales[[i]]),
matrix(matriz_edad_estandar[,1]),0),3)
}
matriz_Est_numerico
